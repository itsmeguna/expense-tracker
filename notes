Folder Setup in VS Code 
expense-tracker/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py            # Make app a package
â”‚   â”œâ”€â”€ main.py                # Entry point for FastAPI app
â”‚   â”œâ”€â”€ models.py              # SQLAlchemy models
â”‚   â”œâ”€â”€ schemas.py             # Pydantic schemas
â”‚   â”œâ”€â”€ database.py            # PostgreSQL connection setup
â”‚   â”œâ”€â”€ crud.py                # Business logic (optional early)
â”‚   â””â”€â”€ routes/
â”‚       â”œâ”€â”€ __pycache__       
â”‚       â””â”€â”€ expenses.py        # All /expenses endpoints
â”‚       â”œâ”€â”€ balance.py         # All /balance endpoints
â”‚       â””â”€â”€ income.py          # All /income endpoints
â”‚       â””â”€â”€ savings.py         # All /savings endpoints
â”‚       â”œâ”€â”€ summary.py         # All /summary endpoints
â”œâ”€â”€ requirements.txt           # Project dependencies
â”œâ”€â”€ Dockerfile                 # Dockerfile
â”œâ”€â”€ docker-compose.yml         # Docker compose file


1.mkdir expense_tracker
cd expense_tracker
python -m venv venv
venv\Scripts\activate       # Windows: venv\Scripts\activate
mkdir app
3.New-Item requirements.txt -ItemType File
New-Item app\__init__.py -ItemType File
New-Item app\main.py -ItemType File
New-Item app\models.py -ItemType File
New-Item app\schemas.py -ItemType File
New-Item app\database.py -ItemType File
New-Item app\crud.py -ItemType File
New-Item app\routes.py -ItemType File

uvicorn app.main:app --reload
git init  
git remote add origin https://github.com/itsmeguna/expense-tracker.git     
git add .   
git status                                                                                                          
git commit -m "Backup before dockerization" 
git branch -M main 
git push -u origin main 
git pull --rebase origin main 
git push -u origin main                                      

pip list
docker build -t fastapi-expense-app .
docker run -d -p 8000:8000 fastapi-expense-app

docker-compose down --volumes
docker-compose up --build
docker rm -f fastapi_expense_app


ðŸ”¹ 1. Expense CRUD Functionality
Feature	Status
âœ… Add expense (POST)	Done
âœ… Get all expenses (GET)	Done
âœ… Get expenses by date range	Done
âœ… Get expense by ID (GET)	Done
âœ… Get expenses by category with sum	âœ… Done
âœ… Update expense (PUT)	Done
âœ… Delete expense (DELETE)	Done
âœ… Get monthly grouped summary	âœ… Done

ðŸ”¹ 2. Income & Savings
Feature	Status
âœ… Add income	Done
âœ… Balance	Done
âœ… Add savings	Done

ðŸ”¹ 3. Database
Concern	Status
âœ… Using PostgreSQL	Done
âš ï¸ Migrations (e.g., Alembic)	Not done ye-->(Later)
âž• Model improvement for user_id	Future enhancement (multi-user)-->ToDo 

ðŸ”¹ 4. Frontend
Component	Status
âœ… Swagger Docs	Available
âœ… API-only usage	Yes

ðŸ”¹ 5. Authentication
Question	Status
âœ… Login planned?	Yes (future)-- to do

ðŸ”¹ 6. Summary/Reports
Feature	Status
âœ… Show total per category	Done
âœ… Monthly grouping summary	Done
ðŸ’¡ Charts (pie/bar)	Idea â€”  later
âž• Multi-month summary view	âœ… Done (via GET by month list)

ðŸ”¹ 7. Dockerization & Testing
Task	Status
ðŸ”² Dockerize app	yet To do
ðŸ”² Write tests	yet To do (start with basic route tests)

{
    "email": "user1@example.com",
    "password": "test1243"
}

start_date=2025-07-01&end_date=2025-07-30



Here is a concise overview of how OOP (Object-Oriented Programming) concepts are applied in my
FastAPI Expense Tracker project, tailored for my demo:

âœ… 1. Encapsulation
Encapsulation is about bundling data (attributes) and methods (functions) into
single units (classes) and restricting direct access.

In your code:

models.py encapsulates DB table structures using SQLAlchemy models.
class Expense(Base):
    __tablename__ = "expenses"
    id = Column(Integer, primary_key=True, index=True)
    category = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    note = Column(String)

routes/expenses.py encapsulates logic for creating, updating, deleting expenses.
schemas.py defines request and response models (Pydantic) to encapsulate data validation logic.

âœ… 2. Abstraction
Abstraction hides complex logic behind simple interfaces.

In your code:

You expose simple API endpoints (POST /expenses, GET /summary) while hiding:

JWT auth logic

SQL queries

Database transactions

The frontend (or API client) doesnâ€™t need to know how data is stored or validatedâ€”it just
consumes the abstracted endpoints.

âœ… 3. Inheritance
Inheritance allows classes to reuse logic from base classes.

In your code:

All models inherit from Base (Base = declarative_base() from SQLAlchemy).

python

class Expense(Base):
    ...
This gives them SQLAlchemys ORM capabilities (e.g., table mapping, metadata).

âœ… 4. Polymorphism
Polymorphism lets the same method name behave differently depending on the context.

In your code:

You might have get_summary() in multiple routes (e.g., expenses, income) that return different
results based on the data.

Similarly, methods like create(), update() behave differently for each model (Expense, 
Income, Savings), but share the same interface pattern.

ðŸŽ¯ Bonus Points You Can Mention
Single Responsibility: Your modules (e.g., auth.py, summary.py) each do one thingâ€”this is good 
OOP design.

Reusability: Models, schemas, and shared utils (e.g., DB session, JWT logic) are reusable across
the project.

If youâ€™re asked "How did you apply OOP principles?", answer:

"I used encapsulation to separate database, logic, and validation layers; abstraction to hide DB
and auth complexities behind API endpoints; inheritance via SQLAlchemy models; and polymorphism 
through route behaviors that share interfaces but differ in implementation."





